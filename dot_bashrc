# -*- mode: shell-script -*-

# If not running interactively, don't do anything
[ -z "$PS1" ] && return

# My functions
. ~/myconfigs/functions

color_term=$(set_term)
set_editor
set_manpath
configure_history

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# make less more friendly for non-text input files, see
# lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

prepend_once_to_path "$HOME/bin"
prepend_once_to_path "/usr/local/bin"
add_once_to_path "$HOME/homebrew/bin"
add_once_to_path "$HOME/Library/iTunes/Scripts/iTunes-LAME.app/Contents/Resources/"
add_once_to_path "/usr/local/mysql/bin"
add_once_to_path "/usr/local/sbin"
add_once_to_path "$HOME/Code/Android/android-sdk-mac_86/tools/"

# Merge all shells' histories together.
# export PROMPT_COMMAND="history -a; history -c; history -r; $PROMPT_COMMAND"

if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
fi

if [[ $color_term -ne 0 ]]; then
    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

if [ -f /etc/bash_completion ] && ! shopt -oq posix; then
    . /etc/bash_completion
fi

if [ -f ~/.bash_aliases ]; then
 . ~/.bash_aliases
fi

if [ -f ~/myconfigs/dot_bash_aliases ]; then
 . ~/myconfigs/dot_bash_aliases
fi

if [ -f ~/.bash_aliases_jamie ]; then
 . ~/.bash_aliases_jamie
fi

brew_binary=$(configure_homebrew)

git_function_files=$(find_git_bash_functions)
for f in $git_function_files
do
    . $f
done

have_git_ps1_function=0
if [[ -n $git_function_files ]]; then
    type -t __git_ps1 | grep -qE 'shell|function' && have_git_ps1_function=1
    if [[ $have_git_ps1_function -eq 0 ]]; then
        echo "Loaded git completion but not prompt functions."
    fi
else
    echo "Could not find Git bash functions."
fi

if [[ $have_git_ps1_function -ne 0 ]]; then
    # Include the current Git branch in the prompt.
    show_git_branch_fn='$(__git_ps1 "(branch: %s)")'
fi

if [[ $color_term -ne 0 ]]; then
    # Note: ~/bin/show-term-colors.sh shows terminal color codes
    # ex 47;1;37m is bold white on gray BG
    no_color="\[\033[0m\]"
    prompt_color="\[\033[30;47m\]"
    prompt_color_2="\[\033[35m\]"
fi
# Build the PS1 prompt, with or without the git branch, and with or without color.
PS1=${prompt_color}'\D{%a %-m/%-d} \t \u@\h \w '"${show_git_branch_fn}"${no_color}'\n'${prompt_color_2}'\$ '${no_color}

if [[ -f ~/.alias_completion_function ]]; then
    source ~/.alias_completion_function
fi

if [[ -n `which p4` ]]; then
    export P4CONFIG=.p4config
    export P4EDITOR=$EDITOR
fi

# a nice MySQL prompt
export MYSQL_PS1="\r:\m:\s \h \d \nmysql>"

#
# Try and use RVM if available
#
enable_rvm=1
if [[ $enable_rvm ]]; then
    # modified from what the RVM installer added to first check for RVM
    if [ -d $HOME/.rvm/ ]; then
        PATH=$PATH:$HOME/.rvm/bin # Add RVM to PATH for scripting
    fi
    if [[ "rvm is a function" != "`type -t rvm | head -n 1`" ]]; then
        [[ -s "$HOME/.rvm/scripts/rvm" ]] && source "$HOME/.rvm/scripts/rvm" # Load RVM into a shell session *as a function*
    fi
fi

#
# Try and use rbenv if available
#
if [ -e /usr/local/bin/brew ]; then
    export RBENV_ROOT=/usr/local/var/rbenv
fi
if which rbenv > /dev/null; then eval "$(rbenv init -)"; fi

if [[ -f ~/.bashrc_local ]]; then
    . ~/.bashrc_local
fi
